# JavaScript-作用域链和原型链

## 作用域链

### 作用域

在运行时，指示当前代码对于其他特定部分的函数、变量或对象是否具有访问权；其作用是形成隔离的独立区域，处于不同作用域的同名变量不会冲突，解决全局变量被污染的情况出现

### 作用域分类

在ES6前，只有全局作用域与局部作用域（函数作用域），ES6新增块级作用域：

#### 全局作用域

+ 最外层变量
+ 最外层函数（只是函数，不包括其中的函数或变量）
+ 未声明直接赋值的变量，会被自动声明，并处于全局作用域
+ window对象的属性都处于全局作用域

#### 局部作用域（函数作用域）

+ 声明在函数块内部的变量，一般只有本函数内才能访问到
+ 多层函数作用域嵌套时，内层作用域可以访问到外层作用域的变量，反之则不行，这也是闭包的原理

+ 块语句不会创造一个函数作用域，其中的变量依然处于最近的作用域中

> 闭包：在一个内层函数中访问到其外层函数的作用域，该内层函数即是闭包
>
> 块语句：如 if 和 switch 条件语句或 for 和 while 循环语句，被花括号包裹起来的语句

#### 块级作用域

+ ES6新增，通过`let`或`const`关键词声明的变量，处于所处**块语句**或**函数块**范围的作用域
+ 不可在同一块级作用域中重复声明已经使用`let`或`const`关键词声明过的变量
+ 循环中的块级作用域： 循环中，不但循环语句是一个父作用域，并且循环体也是一个子作用域
+ 和函数作用域一样，内作用域可以访问外作用域，反之则不行

循环体中重复声明也不会报错，说明处于不同的作用域中；而循环语句中的变量可以被循环体访问到，说明两个作用域为父子关系

```js
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
// abc * 3
for (let i = 0; i < 3; i++) {
  console.log(i);
}
// 0 1 2
```

### 作用域链

前面提到：

1. 作用域规定了对于其他变量、函数或对象的访问权限
2. 嵌套的作用域中，内部的作用域可以访问到外部的作用域范文
3. 最外层的作用域即为全局作用域

当代码需要调用某个变量时，首先在本作用域中试图访问该变量，如果没有找到，则向上级作用域一级一级访问，直到找到该变量返回，或到了全局作用域都没有找到时返回空，这层层连接的关系作用域链，该访问的过程便是遍历作用域链的过程。

## 原型链

+ JavaScript的对象都有`__proto__`属性，称为原型，指向它的<u>构造函数</u>的原型对象`prototype`；
    + 如字符串`'a'`的`__proto__`指向`String.prototype`
+ 对象继承原型对象的属性和方法（函数）
  + 原型也是对象，也有原型，层层叠加构成原型链；
+ 原型链的链头都是`Object.prototype`，`Object.prototype`的原型是`null`，不计入原型链
+ `prototype`与`constructor`的关系
  + 对于一个函数，使用`new`操作符就可以变为一个构造函数
    + 构造函数的`prototype(原型)`为构造函数的原型
    + 构造函数的原型的`constructor(构造函数)`为构造函数
+ 显式原型`prototype`和隐式原型`__proto__`

    + 对象都有`__proto__`属性，函数对象同时具有`__proto__`和`prototype`属性
    + `_proto_`是隐式原型属性，指向了**创建该对象的构造函数的原型**
+ 读取属性时从尾到头读取，同名属性优先读取下层属性，上层属性未被读取称为“属性遮蔽”；一级级向上寻找对性能有影响