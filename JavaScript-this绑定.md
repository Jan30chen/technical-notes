# JavaScript-this绑定

> 参考：https://www.cnblogs.com/echolun/p/11962610.html

## 默认绑定

单独调用函数时，如`fn()`：

+ **一般情况下**，默认绑定时,`this`指向**全局对象`window`**
+ **严格模式下**，指向`undefined`
+ 严格模式下调用不在严格模式中的函数，`this`不受影响

## 隐式绑定

对象调用了函数，如`obj.fn()`时：

+ 只有单一对象时，`this`会隐式绑定到该对象上
+ 多个对象调用时，`this`绑定到最近的对象上

### 隐式绑定的丢失

当函数本身被作为参数传递或给变量赋值时，`this`并没有和函数一起被传入，此时其丢失

```js
fn1(obj.fn);		//作为参数
let fn2 = obj.fn;	//给变量赋值
```

丢失的`this`指向全局对象，但是有可能会在之后被绑定到其他对象中，所以**并不总是指向`window`**

## 显式绑定

与之前两种不同，是我们主动通过`call`、`apply`以及`bind`方法改变`this`的行为

```js
fn(); 
fn.call(obj1); 
fn.apply(obj2); 
fn.bind(obj3)(); 
```

指向参数提供的是`null`或者`undefined`，那么`this`将指向全局对象

### 三种绑定函数的区别

1. 三者都用于改变`this`的绑定，将fn函数的`this`的指向参数的`this`
2. `call`和`apply`改变绑定并执行，**只改变和执行一次**，下次还需要重新更改绑定
3. `bind`返回全新的`boundFcuntion`绑定函数，所以需要用()执行；且该函数**无法再次被更改**绑定
4. `call`的形参是散列形式，`apply`的形参为数组，所以**传参情况下`call`性能更优**

## `new`构造绑定

`new`函数大致分为三步：

1. 以构造器的prototype属性为原型，创建新对象；
2. 将this(可以理解为上句创建的新对象)和调用参数传给构造器，执行；
3. 如果构造器没有手动返回对象，则返回第一步创建的对象

通过`new`构造一个新对象，在这个构造函数内，`this`指向生成的这个新对象

## 绑定优先级

+ 显式绑定 > 隐式绑定 > 默认绑定
+ new绑定 > 隐式绑定 > 默认绑定
+ new绑定和显式绑定一起使用会报错

## 特殊：箭头函数

ES6中新出现的箭头函数比较特殊，`this`具有以下的特点：

+ 箭头函数的`this`指向取决于外层作用域中的`this`
+ 箭头函数的`this`需要靠修改外层作用域的`this`间接修改

